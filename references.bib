@article{how-programmers-interact-with-code-generation-models,
 author = "Shraddha Barke, Michael B. James, Nadia Polikarpova",
 title = {{Grounded Copilot: How Programmers Interact with Code-Generating Models}},
 url = "https://arxiv.org/abs/2206.15000",
 year = "2022",
}
@article{elaborator-reflection-extending-idris-in-idris,
author = {Christiansen, David and Brady, Edwin},
title = {Elaborator Reflection: Extending Idris in Idris},
year = {2016},
issue_date = {September 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/3022670.2951932},
doi = {10.1145/3022670.2951932},
abstract = {Many programming languages and proof assistants are defined by elaboration from a high-level language with a great deal of implicit information to a highly explicit core language. In many advanced languages, these elaboration facilities contain powerful tools for program construction, but these tools are rarely designed to be repurposed by users. We describe elaborator reflection, a paradigm for metaprogramming in which the elaboration machinery is made directly available to metaprograms, as well as a concrete realization of elaborator reflection in Idris, a functional language with full dependent types. We demonstrate the applicability of Idris’s reflected elaboration framework to a number of realistic problems, we discuss the motivation for the specific features of its design, and we explore the broader meaning of elaborator reflection as it can relate to other languages.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {284–297},
numpages = {14},
}
@InProceedings{tactic-language-for-the-system-coq,
author="Delahaye, David",
editor="Parigot, Michel
and Voronkov, Andrei",
title="{A Tactic Language for the System Coq}",
booktitle="Logic for Programming and Automated Reasoning",
year="2000",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="85--95",
abstract="We propose a new tactic language for the system Coq, which is intended to enrich the current tactic combinators (tacticals). This language is based on a functional core with recursors and matching operators for Coq terms but also for proof contexts. It can be used directly in proof scripts or in toplevel definitions (tactic definitions). We show that the implementation of this language involves considerable changes in the interpretation of proof scripts, essentially due to the matching operators. We give some examples which solve small proof parts locally and some others which deal with non-trivial problems. Finally, we discuss the status of this meta-language with respect to the Coq language and the implementation language of Coq.",
isbn="978-3-540-44404-6"
}
@InProceedings{auto-in-agda,
author="Kokke, Wen
and Swierstra, Wouter",
editor="Hinze, Ralf
and Voigtl{\"a}nder, Janis",
title="{Auto in Agda}",
booktitle="Mathematics of Program Construction",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="276--301",
abstract="As proofs in type theory become increasingly complex, there is a growing need to provide better proof automation. This paper shows how to implement a Prolog-style resolution procedure in the dependently typed programming language Agda. Connecting this resolution procedure to Agda's reflection mechanism provides a first-class proof search tactic for first-order Agda terms. As a result, writing proof automation tactics need not be different from writing any other program.",
isbn="978-3-319-19797-5"
}
@article{affine-type-system-with-hindley-milner,
author = {Li, Gonglin},
year = {2022},
month = {03},
pages = {},
title = {{An Affine Type System with Hindley-Milner Style Type Inference}}
}
@techreport{proof-procedure-for-the-logic-of-hereditary-harrop-formulas,
author = {Nadathur, Gopalan},
title = {{A Proof Procedure for the Logic of Hereditary Harrop Formulas}},
year = {1992},
publisher = {Duke University},
address = {USA},
pages = {204-209}
}
@article{propositions-as-types,
author = {Wadler, Philip},
title = {{Propositions as Types}},
year = {2015},
issue_date = {December 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {58},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/2699407},
doi = {10.1145/2699407},
abstract = {Connecting mathematical logic and computation, it ensures that some aspects of programming are absolute.},
journal = {Commun. ACM},
month = {nov},
pages = {75–84},
numpages = {10}
}
@book{design-patterns-elements-of-reusable-oo-software,
  title={Design Patterns: Elements of Reusable Object-Oriented Software},
  author={Gamma, E. and Helm, R. and Johnson, R. and Vlissides, J.},
  isbn={9783827330437},
  lccn={94334264},
  series={Addison-Wesley professional computing series},
  url={https://books.google.ee/books?id=tmNNfSkfTlcC},
  year={1995},
  publisher={Addison-Wesley}
}
@InProceedings{tool-for-automated-theorem-proving-in-agda,
author="Lindblad, Fredrik
and Benke, Marcin",
editor="Filli{\^a}tre, Jean-Christophe
and Paulin-Mohring, Christine
and Werner, Benjamin",
title="A Tool for Automated Theorem Proving in Agda",
booktitle="Types for Proofs and Programs",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="154--169",
isbn="978-3-540-31429-5"
}
@InProceedings{dependently-typed-programming-in-agda,
author="Bove, Ana
and Dybjer, Peter
and Norell, Ulf",
editor="Berghofer, Stefan
and Nipkow, Tobias
and Urban, Christian
and Wenzel, Makarius",
title="A Brief Overview of Agda -- A Functional Language with Dependent Types",
booktitle="Theorem Proving in Higher Order Logics",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="73--78",
isbn="978-3-642-03359-9",
url="https://doi.org/10.1007/978-3-642-03359-9_6"
}
@InProceedings{mimer,
author="Skystedt, Lukas",
title="A New Synthesis Tool for Agda",
year="2022",
url="https://hdl.handle.net/20.500.12380/305712"
}
@article{smyth,
author = {Lubin, Justin and Collins, Nick and Omar, Cyrus and Chugh, Ravi},
title = {Program sketching with live bidirectional evaluation},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
url = {https://doi.org/10.1145/3408991},
doi = {10.1145/3408991},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {109},
numpages = {29},
keywords = {Sketches, Program Synthesis, Examples, Bidirectional Evaluation}
}
@article{algebraic-foundations-of-proof-refinement,
  author       = {Jonathan Sterling and
                  Robert Harper},
  title        = {Algebraic Foundations of Proof Refinement},
  journal      = {CoRR},
  volume       = {abs/1703.05215},
  year         = {2017},
  url          = {http://arxiv.org/abs/1703.05215},
  eprinttype    = {arXiv},
  eprint       = {1703.05215},
  timestamp    = {Mon, 13 Aug 2018 16:49:17 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/SterlingH17.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{telescopic-mappings-typed-lamda-calc,
  title={Telescopic mappings in typed lambda calculus},
  author={de Bruijn, Nicolas G},
  journal={Information and Computation},
  volume={91},
  number={2},
  pages={189--204},
  year={1991},
  publisher={Elsevier}
}
@article{idris2-design-and-implementation,
title={Idris, a general-purpose dependently typed programming language: Design and implementation},
volume={23},
DOI={10.1017/S095679681300018X},
number={5},
journal={Journal of Functional Programming},
author={Brady, Edwin},
year={2013},
pages={552–593}
}
@article{rust-program-synthesis,
author = {Fiala, Jon\'{a}\v{s} and Itzhaky, Shachar and M\"{u}ller, Peter and Polikarpova, Nadia and Sergey, Ilya},
title = {Leveraging Rust Types for Program Synthesis},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {PLDI},
url = {https://doi.org/10.1145/3591278},
doi = {10.1145/3591278},
abstract = {The Rust type system guarantees memory safety and data-race freedom. However, to satisfy Rust's type rules, many familiar implementation patterns must be adapted substantially. These necessary adaptations complicate programming and might hinder language adoption. In this paper, we demonstrate that, in contrast to manual programming, automatic synthesis is not complicated by Rust's type system, but rather benefits in two major ways. First, a Rust synthesizer can get away with significantly simpler specifications. While in more traditional imperative languages, synthesizers often require lengthy annotations in a complex logic to describe the shape of data structures, aliasing, and potential side effects, in Rust, all this information can be inferred from the types, letting the user focus on specifying functional properties using a slight extension of Rust expressions. Second, the Rust type system reduces the search space for synthesis, which improves performance.  

In this work, we present the first approach to automatically synthesizing correct-by-construction programs in safe Rust. The key ingredient of our synthesis procedure is Synthetic Ownership Logic, a new program logic for deriving programs that are guaranteed to satisfy both a user-provided functional specification and, importantly, Rust's intricate type system. We implement this logic in a new tool called RusSOL. Our evaluation shows the effectiveness of RusSOL, both in terms of annotation burden and performance, in synthesizing provably correct solutions to common problems faced by new Rust developers.},
journal = {Proc. ACM Program. Lang.},
month = {jun},
articleno = {164},
numpages = {24},
keywords = {Rust, program logic, program synthesis, type systems}
}
@Inproceedings{redprl,
  author    = {Angiuli, Carlo and Cavallo, Evan and Hou (Favonia), Kuen-Bang and Harper, Robert and Sterling, Jonathan},
  year      = {2018},
  title     = {The RedPRL Proof Assistant (Invited Paper)},
  editor    = {Blanqui, Fr\'ed\'eric and Reis, Giselle},
  booktitle = {{Proceedings of the 13th International Workshop on}
               Logical Frameworks and Meta-Languages: Theory and Practice,
               {Oxford, UK, 7th July 2018}},
  series    = {Electronic Proceedings in Theoretical Computer Science},
  volume    = {274},
  publisher = {Open Publishing Association},
  pages     = {1-10},
  doi       = {10.4204/EPTCS.274.1},
}
@Inproceedings{code-prediction-trees-transformers,
  author={Kim, Seohyun and Zhao, Jinman and Tian, Yuchi and Chandra, Satish},
  booktitle={2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)}, 
  title={Code Prediction by Feeding Trees to Transformers}, 
  year={2021},
  volume={},
  number={},
  pages={150-162},
  keywords={Pipelines;Computer architecture;Syntactics;Proposals;Standards;Python;Software engineering;code embedding;code prediction;autocomplete},
  doi={10.1109/ICSE43902.2021.00026}
}
@inproceedings{pre-trained-llm-code-gen,
author = {Zheng, Qinkai and Xia, Xiao and Zou, Xu and Dong, Yuxiao and Wang, Shan and Xue, Yufei and Shen, Lei and Wang, Zihan and Wang, Andi and Li, Yang and Su, Teng and Yang, Zhilin and Tang, Jie},
title = {CodeGeeX: A Pre-Trained Model for Code Generation with Multilingual Benchmarking on HumanEval-X},
year = {2023},
isbn = {9798400701030},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3580305.3599790},
doi = {10.1145/3580305.3599790},
abstract = {Large pre-trained code generation models, such as OpenAI Codex, can generate syntax-and function-correct code, making the coding of programmers more productive. In this paper, we introduce CodeGeeX, a multilingual model with 13 billion parameters for code generation. CodeGeeX is pre-trained on 850 billion tokens of 23 programming languages as of June 2022. Our extensive experiments suggest that CodeGeeX outperforms multilingual code models of similar scale for both the tasks of code generation and translation on HumanEval-X. Building upon HumanEval (Python only), we develop the HumanEval-X benchmark for evaluating multilingual models by hand-writing the solutions in C++, Java, JavaScript, and Go. In addition, we build CodeGeeX-based extensions on Visual Studio Code, JetBrains, and Cloud Studio, generating 8 billion tokens for tens of thousands of active users per week. Our user study demonstrates that CodeGeeX can help to increase coding efficiency for 83.4\% of its users. Finally, CodeGeeX is publicly accessible since Sep. 2022, we open-sourced its code, model weights, API, extensions, and HumanEval-X at https://github.com/THUDM/CodeGeeX.},
booktitle = {Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining},
pages = {5673–5684},
numpages = {12},
keywords = {code generation, large language model, pre-trained model},
location = {, Long Beach, CA, USA, },
series = {KDD '23}
}
@book{compiler-design,
author = {Bergmann, Seth D.},
title = {Compiler Design: Theory, Tools, and Examples},
year = {1994},
isbn = {0697170861},
doi = {10.31986/issn.2689-0690_rdw.oer.1001},
publisher = {McGraw-Hill Professional},
edition = {1st}
}
@inproceedings{editing-support-for-languages-lsp,
author = {Barros, Djonathan and Peldszus, Sven and Assun\c{c}\~{a}o, Wesley K. G. and Berger, Thorsten},
title = {Editing support for software languages: implementation practices in language server protocols},
year = {2022},
isbn = {9781450394666},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3550355.3552452},
doi = {10.1145/3550355.3552452},
abstract = {Effectively using software languages, be it programming or domain-specific languages, requires effective editing support. Modern IDEs, modeling tools, and code editors typically provide sophisticated support to create, comprehend, or modify instances---programs or models---of particular languages. Unfortunately, building such editing support is challenging. While the engineering of languages is well understood and supported by modern model-driven techniques, there is a lack of engineering principles and best practices for realizing their editing support. Especially domain-specific languages---often created by smaller organizations or individual developers, sometimes even for single projects---would benefit from better methods and tools to create proper editing support.We study practices for implementing editing support in 30 so-called language servers---implementations of the language server protocol (LSP). The latter is a recent de facto standard to realize editing support for languages, separated from the editing tools (e.g., IDEs or modeling tools), enhancing the reusability and quality of the editing support. Witnessing the LSP's popularity---a whopping 121 language servers are in existence today---we take this opportunity to analyze the implementations of 30 language servers, some of which support multiple languages. We identify concerns that developers need to take into account when developing editing support, and we synthesize implementation practices to address them, based on a systematic analysis of the servers' source code. We hope that our results shed light on an important technology for software language engineering, that facilitates language-oriented programming and systems development, including model-driven engineering.},
booktitle = {Proceedings of the 25th International Conference on Model Driven Engineering Languages and Systems},
pages = {232–243},
numpages = {12},
keywords = {source code editor, language engineering, implementation practices, code assistance},
location = {Montreal, Quebec, Canada},
series = {MODELS '22}
}
@ARTICLE{usability-of-ownership,
       author = {{Crichton}, Will},
        title = "{The Usability of Ownership}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Programming Languages, Computer Science - Human-Computer Interaction},
         year = 2020,
        month = nov,
          eid = {arXiv:2011.06171},
        pages = {arXiv:2011.06171},
          doi = {10.48550/arXiv.2011.06171},
archivePrefix = {arXiv},
       eprint = {2011.06171},
 primaryClass = {cs.PL},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2020arXiv201106171C},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}
@article{graph-searching,
author = {Corneil, Derek G. and Krueger, Richard M.},
title = {A Unified View of Graph Searching},
year = {2008},
issue_date = {October 2008},
publisher = {Society for Industrial and Applied Mathematics},
address = {USA},
volume = {22},
number = {4},
issn = {0895-4801},
url = {https://doi.org/10.1137/050623498},
doi = {10.1137/050623498},
abstract = {Graph searching is perhaps one of the simplest and most widely used tools in graph algorithms. Despite this, few theoretical results are known about the vertex orderings that can be produced by a specific search algorithm. A simple characterizing property, such as is known for LexBFS, can aid greatly in devising algorithms, writing proofs of correctness, and showing impossibility results. This paper unifies our view of graph search algorithms by showing simple, closely related characterizations of various well-known search paradigms, including BFS and DFS. Furthermore, these characterizations naturally lead to other search paradigms, namely, maximal neighborhood search and LexDFS.},
journal = {SIAM J. Discret. Math.},
month = {jul},
pages = {1259–1276},
numpages = {18},
keywords = {graph traversal, graph searching, depth-first search, breadth-first search, LexBFS}
}
@article{rice-theorem,
title={H. G. Rice. Classes of recursively enumerable sets and their decision problems. Transactions of the American Mathematical Society, vol. 74 (1953) pp. 358–366.},
volume={19},
DOI={10.2307/2268870},
number={2},
journal={Journal of Symbolic Logic},
author={Péter, Rózsa},
year={1954},
pages={121–122}
}
@inproceedings{typing-latency,
author = {Thomas, Richard C. and Karahasanovic, Amela and Kennedy, Gregor E.},
title = {An investigation into keystroke latency metrics as an indicator of programming performance},
year = {2005},
isbn = {1920682244},
publisher = {Australian Computer Society, Inc.},
address = {AUS},
abstract = {Typing has long been studied in psychology and HCI, and strong cognitive models for transcription typing exist. The goal of the present research was to test if there is any correlation between students' keystroking speed and performance while they are programming. We present the results from two studies with computer science students conducted in different contexts. Keystroke timings were recorded while they worked on Java and Ada source code. Quality of their programming work was measured mainly in terms of completeness. In the controlled experiment that lasted six hours, 39 students undertook three change tasks on a 6000 LOC Java application. In the field study, data was collected over 6 weeks from 141 students while they worked unsupervised on Ada programming in first year laboratories. In both cases there were highly significant (P=0.001), moderately strong, negative correlations between speed and coding performance. With additional development, these techniques may have promise for user modelling and assessment as well as in educational diagnostics.},
booktitle = {Proceedings of the 7th Australasian Conference on Computing Education - Volume 42},
pages = {127–134},
numpages = {8},
keywords = {chunking, digraph latencies, empirical methods, keystroke model, programming performance},
location = {, Newcastle, New South Wales, Australia, },
series = {ACE '05}
}
@book{usability-engineering,
  title={Usability engineering},
  author={Nielsen, Jakob},
  year={1994},
  publisher={Morgan Kaufmann}
}
@article{suslik,
author = {Polikarpova, Nadia and Sergey, Ilya},
title = {Structuring the synthesis of heap-manipulating programs},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290385},
doi = {10.1145/3290385},
abstract = {This paper describes a deductive approach to synthesizing imperative programs with pointers from declarative specifications expressed in Separation Logic. Our synthesis algorithm takes as input a pair of assertions—a pre- and a postcondition—which describe two states of the symbolic heap, and derives a program that transforms one state into the other, guided by the shape of the heap. Our approach to program synthesis is grounded in proof theory: we introduce the novel framework of Synthetic Separation Logic (SSL), which generalises the classical notion of heap entailment P ⊢ Q to incorporate a possibility of transforming a heap satisfying an assertion P into a heap satisfying an assertion Q. A synthesized program represents a proof term for a transforming entailment statement P ↝ Q, and the synthesis procedure corresponds to a proof search. The derived programs are, thus, correct by construction, in the sense that they satisfy the ascribed pre/postconditions, and are accompanied by complete proof derivations, which can be checked independently. We have implemented a proof search engine for SSL in a form of the program synthesizer called SuSLik. For efficiency, the engine exploits properties of SSL rules, such as invertibility and commutativity of rule applications on separate heaps, to prune the space of derivations it has to consider. We explain and showcase the use of SSL on characteristic examples, describe the design of SuSLik, and report on our experience of using it to synthesize a series of benchmark programs manipulating heap-based linked data structures.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {72},
numpages = {30},
keywords = {Program Synthesis, Proof Systems, Separation Logic, Type Theory}
}

  







@online{rust,
  author = {{The Rust Programming Language team}},
  title = {Rust Programming Language},
  url = {https://www.rust-lang.org/},
  archivedurl = {https://web.archive.org/web/20240409193051/https://www.rust-lang.org/},
  urldate = {2024-04-06}
}