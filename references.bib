@article{how-programmers-interact-with-code-generation-models,
 author = "Shraddha Barke, Michael B. James, Nadia Polikarpova",
 title = {{Grounded Copilot: How Programmers Interact with Code-Generating Models}},
 url = "https://arxiv.org/abs/2206.15000",
 year = "2022",
}
@article{elaborator-reflection-extending-idris-in-idris,
author = {Christiansen, David and Brady, Edwin},
title = {Elaborator Reflection: Extending Idris in Idris},
year = {2016},
issue_date = {September 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/3022670.2951932},
doi = {10.1145/3022670.2951932},
abstract = {Many programming languages and proof assistants are defined by elaboration from a high-level language with a great deal of implicit information to a highly explicit core language. In many advanced languages, these elaboration facilities contain powerful tools for program construction, but these tools are rarely designed to be repurposed by users. We describe elaborator reflection, a paradigm for metaprogramming in which the elaboration machinery is made directly available to metaprograms, as well as a concrete realization of elaborator reflection in Idris, a functional language with full dependent types. We demonstrate the applicability of Idris’s reflected elaboration framework to a number of realistic problems, we discuss the motivation for the specific features of its design, and we explore the broader meaning of elaborator reflection as it can relate to other languages.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {284–297},
numpages = {14},
}
@InProceedings{tactic-language-for-the-system-coq,
author="Delahaye, David",
editor="Parigot, Michel
and Voronkov, Andrei",
title="{A Tactic Language for the System Coq}",
booktitle="Logic for Programming and Automated Reasoning",
year="2000",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="85--95",
abstract="We propose a new tactic language for the system Coq, which is intended to enrich the current tactic combinators (tacticals). This language is based on a functional core with recursors and matching operators for Coq terms but also for proof contexts. It can be used directly in proof scripts or in toplevel definitions (tactic definitions). We show that the implementation of this language involves considerable changes in the interpretation of proof scripts, essentially due to the matching operators. We give some examples which solve small proof parts locally and some others which deal with non-trivial problems. Finally, we discuss the status of this meta-language with respect to the Coq language and the implementation language of Coq.",
isbn="978-3-540-44404-6"
}
@InProceedings{auto-in-agda,
author="Kokke, Wen
and Swierstra, Wouter",
editor="Hinze, Ralf
and Voigtl{\"a}nder, Janis",
title="{Auto in Agda}",
booktitle="Mathematics of Program Construction",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="276--301",
abstract="As proofs in type theory become increasingly complex, there is a growing need to provide better proof automation. This paper shows how to implement a Prolog-style resolution procedure in the dependently typed programming language Agda. Connecting this resolution procedure to Agda's reflection mechanism provides a first-class proof search tactic for first-order Agda terms. As a result, writing proof automation tactics need not be different from writing any other program.",
isbn="978-3-319-19797-5"
}
@article{affine-type-system-with-hindley-milner,
author = {Li, Gonglin},
year = {2022},
month = {03},
pages = {},
title = {{An Affine Type System with Hindley-Milner Style Type Inference}}
}
@techreport{proof-procedure-for-the-logic-of-hereditary-harrop-formulas,
author = {Nadathur, Gopalan},
title = {{A Proof Procedure for the Logic of Hereditary Harrop Formulas}},
year = {1992},
publisher = {Duke University},
address = {USA},
pages = {204-209}
}
@article{propositions-as-types,
author = {Wadler, Philip},
title = {{Propositions as Types}},
year = {2015},
issue_date = {December 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {58},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/2699407},
doi = {10.1145/2699407},
abstract = {Connecting mathematical logic and computation, it ensures that some aspects of programming are absolute.},
journal = {Commun. ACM},
month = {nov},
pages = {75–84},
numpages = {10}
}
@book{design-patterns-elements-of-reusable-oo-software,
  title={Design Patterns: Elements of Reusable Object-Oriented Software},
  author={Gamma, E. and Helm, R. and Johnson, R. and Vlissides, J.},
  isbn={9783827330437},
  lccn={94334264},
  series={Addison-Wesley professional computing series},
  url={https://books.google.ee/books?id=tmNNfSkfTlcC},
  year={1995},
  publisher={Addison-Wesley}
}
@InProceedings{tool-for-automated-theorem-proving-in-agda,
author="Lindblad, Fredrik
and Benke, Marcin",
editor="Filli{\^a}tre, Jean-Christophe
and Paulin-Mohring, Christine
and Werner, Benjamin",
title="A Tool for Automated Theorem Proving in Agda",
booktitle="Types for Proofs and Programs",
year="2006",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="154--169",
isbn="978-3-540-31429-5"
}
@InProceedings{dependently-typed-programming-in-agda,
author="Bove, Ana
and Dybjer, Peter
and Norell, Ulf",
editor="Berghofer, Stefan
and Nipkow, Tobias
and Urban, Christian
and Wenzel, Makarius",
title="A Brief Overview of Agda -- A Functional Language with Dependent Types",
booktitle="Theorem Proving in Higher Order Logics",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="73--78",
isbn="978-3-642-03359-9",
url="https://doi.org/10.1007/978-3-642-03359-9_6"
}
@InProceedings{mimer,
author="Skystedt, Lukas",
title="A New Synthesis Tool for Agda",
year="2022",
url="https://hdl.handle.net/20.500.12380/305712"
}
@article{smyth,
author = {Lubin, Justin and Collins, Nick and Omar, Cyrus and Chugh, Ravi},
title = {Program sketching with live bidirectional evaluation},
year = {2020},
issue_date = {August 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {ICFP},
url = {https://doi.org/10.1145/3408991},
doi = {10.1145/3408991},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {109},
numpages = {29},
keywords = {Sketches, Program Synthesis, Examples, Bidirectional Evaluation}
}
@article{algebraic-foundations-of-proof-refinement,
  author       = {Jonathan Sterling and
                  Robert Harper},
  title        = {Algebraic Foundations of Proof Refinement},
  journal      = {CoRR},
  volume       = {abs/1703.05215},
  year         = {2017},
  url          = {http://arxiv.org/abs/1703.05215},
  eprinttype    = {arXiv},
  eprint       = {1703.05215},
  timestamp    = {Mon, 13 Aug 2018 16:49:17 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/SterlingH17.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@article{telescopic-mappings-typed-lamda-calc,
  title={Telescopic mappings in typed lambda calculus},
  author={de Bruijn, Nicolas G},
  journal={Information and Computation},
  volume={91},
  number={2},
  pages={189--204},
  year={1991},
  publisher={Elsevier}
}
@article{idris2-design-and-implementation,
title={Idris, a general-purpose dependently typed programming language: Design and implementation},
volume={23},
DOI={10.1017/S095679681300018X},
number={5},
journal={Journal of Functional Programming},
author={BRADY, EDWIN},
year={2013},
pages={552–593}
}
@article{rust-program-synthesis,
author = {Fiala, Jon\'{a}\v{s} and Itzhaky, Shachar and M\"{u}ller, Peter and Polikarpova, Nadia and Sergey, Ilya},
title = {Leveraging Rust Types for Program Synthesis},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {PLDI},
url = {https://doi.org/10.1145/3591278},
doi = {10.1145/3591278},
abstract = {The Rust type system guarantees memory safety and data-race freedom. However, to satisfy Rust's type rules, many familiar implementation patterns must be adapted substantially. These necessary adaptations complicate programming and might hinder language adoption. In this paper, we demonstrate that, in contrast to manual programming, automatic synthesis is not complicated by Rust's type system, but rather benefits in two major ways. First, a Rust synthesizer can get away with significantly simpler specifications. While in more traditional imperative languages, synthesizers often require lengthy annotations in a complex logic to describe the shape of data structures, aliasing, and potential side effects, in Rust, all this information can be inferred from the types, letting the user focus on specifying functional properties using a slight extension of Rust expressions. Second, the Rust type system reduces the search space for synthesis, which improves performance.  

In this work, we present the first approach to automatically synthesizing correct-by-construction programs in safe Rust. The key ingredient of our synthesis procedure is Synthetic Ownership Logic, a new program logic for deriving programs that are guaranteed to satisfy both a user-provided functional specification and, importantly, Rust's intricate type system. We implement this logic in a new tool called RusSOL. Our evaluation shows the effectiveness of RusSOL, both in terms of annotation burden and performance, in synthesizing provably correct solutions to common problems faced by new Rust developers.},
journal = {Proc. ACM Program. Lang.},
month = {jun},
articleno = {164},
numpages = {24},
keywords = {Rust, program logic, program synthesis, type systems}
}
@Inproceedings{redprl,
  author    = {Angiuli, Carlo and Cavallo, Evan and Hou (Favonia), Kuen-Bang and Harper, Robert and Sterling, Jonathan},
  year      = {2018},
  title     = {The RedPRL Proof Assistant (Invited Paper)},
  editor    = {Blanqui, Fr\'ed\'eric and Reis, Giselle},
  booktitle = {{\rm Proceedings of the 13th International Workshop on}
               Logical Frameworks and Meta-Languages: Theory and Practice,
               {\rm Oxford, UK, 7th July 2018}},
  series    = {Electronic Proceedings in Theoretical Computer Science},
  volume    = {274},
  publisher = {Open Publishing Association},
  pages     = {1-10},
  doi       = {10.4204/EPTCS.274.1},
}
@Inproceedings{code-prediction-trees-transformers,
  author={Kim, Seohyun and Zhao, Jinman and Tian, Yuchi and Chandra, Satish},
  booktitle={2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)}, 
  title={Code Prediction by Feeding Trees to Transformers}, 
  year={2021},
  volume={},
  number={},
  pages={150-162},
  keywords={Pipelines;Computer architecture;Syntactics;Proposals;Standards;Python;Software engineering;code embedding;code prediction;autocomplete},
  doi={10.1109/ICSE43902.2021.00026}
}
@inproceedings{pre-trained-llm-code-gen,
author = {Zheng, Qinkai and Xia, Xiao and Zou, Xu and Dong, Yuxiao and Wang, Shan and Xue, Yufei and Shen, Lei and Wang, Zihan and Wang, Andi and Li, Yang and Su, Teng and Yang, Zhilin and Tang, Jie},
title = {CodeGeeX: A Pre-Trained Model for Code Generation with Multilingual Benchmarking on HumanEval-X},
year = {2023},
isbn = {9798400701030},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3580305.3599790},
doi = {10.1145/3580305.3599790},
abstract = {Large pre-trained code generation models, such as OpenAI Codex, can generate syntax-and function-correct code, making the coding of programmers more productive. In this paper, we introduce CodeGeeX, a multilingual model with 13 billion parameters for code generation. CodeGeeX is pre-trained on 850 billion tokens of 23 programming languages as of June 2022. Our extensive experiments suggest that CodeGeeX outperforms multilingual code models of similar scale for both the tasks of code generation and translation on HumanEval-X. Building upon HumanEval (Python only), we develop the HumanEval-X benchmark for evaluating multilingual models by hand-writing the solutions in C++, Java, JavaScript, and Go. In addition, we build CodeGeeX-based extensions on Visual Studio Code, JetBrains, and Cloud Studio, generating 8 billion tokens for tens of thousands of active users per week. Our user study demonstrates that CodeGeeX can help to increase coding efficiency for 83.4\% of its users. Finally, CodeGeeX is publicly accessible since Sep. 2022, we open-sourced its code, model weights, API, extensions, and HumanEval-X at https://github.com/THUDM/CodeGeeX.},
booktitle = {Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining},
pages = {5673–5684},
numpages = {12},
keywords = {code generation, large language model, pre-trained model},
location = {, Long Beach, CA, USA, },
series = {KDD '23}
}

  


